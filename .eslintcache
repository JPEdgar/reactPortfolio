[{"C:\\Users\\sevis\\OneDrive\\Desktop\\reactPortfolio\\src\\index.js":"1","C:\\Users\\sevis\\OneDrive\\Desktop\\reactPortfolio\\src\\App.js":"2","C:\\Users\\sevis\\OneDrive\\Desktop\\reactPortfolio\\src\\Grid.jsx":"3","C:\\Users\\sevis\\OneDrive\\Desktop\\reactPortfolio\\src\\GridDetails.js":"4"},{"size":207,"mtime":1609914671404,"results":"5","hashOfConfig":"6"},{"size":484,"mtime":1611643644037,"results":"7","hashOfConfig":"6"},{"size":7950,"mtime":1611651552847,"results":"8","hashOfConfig":"6"},{"size":431,"mtime":1610843179554,"results":"9","hashOfConfig":"6"},{"filePath":"10","messages":"11","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"12"},"kdshg7",{"filePath":"13","messages":"14","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"15","usedDeprecatedRules":"12"},{"filePath":"16","messages":"17","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"18","usedDeprecatedRules":"12"},{"filePath":"19","messages":"20","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"21"},"C:\\Users\\sevis\\OneDrive\\Desktop\\reactPortfolio\\src\\index.js",[],["22","23"],"C:\\Users\\sevis\\OneDrive\\Desktop\\reactPortfolio\\src\\App.js",["24","25"],"import React from \"react\";\r\nimport Grid from \"./Grid\";\r\nfunction App() {\r\n  const setNum = 100;\r\n  const [count, setCount] = React.useState(0);\r\n\r\n  function Add() {\r\n    for (let i = 0; i < setNum; i++) {\r\n      console.log(i);\r\n      setCount((currCount) => currCount + 1);\r\n      // setCount (count + 1)\r\n    }\r\n  }\r\n  return (\r\n    <div>\r\n      {/* <button onClick={() => Add()}>Click</button>\r\n      {\" \" + count} */}\r\n      <Grid />\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default App;\r\n","C:\\Users\\sevis\\OneDrive\\Desktop\\reactPortfolio\\src\\Grid.jsx",["26"],"// useState isn't updating.  Maybe refactor to make grid into an object instead of an arra.\r\n/*\r\nfunction incrementCount(state, props) {\r\n  return {...state, count: state.count + 1};\r\n}\r\n*/\r\nimport React, { useEffect, useState } from \"react\";\r\n\r\nimport { GridDetails, CellDetails, StartNode, EndNode } from \"./GridDetails\";\r\n\r\nimport \"./Grid.css\";\r\n\r\nlet searchArray = [[StartNode.xLoc, StartNode.yLoc]];\r\n\r\nexport default function Grid() {\r\n  const [getGrid, setGrid] = useState(() => InitializeGrid());\r\n\r\n  // render count section\r\n  const renderCount = React.useRef(1);\r\n  useEffect(() => {\r\n    renderCount.current = renderCount.current + 1;\r\n  });\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  function DestroyCell(tempI, currGrid) {\r\n    let tempGrid = [];\r\n    if (currGrid.length === 0) {\r\n      tempGrid = [...getGrid];\r\n    } else {\r\n      tempGrid = [...currGrid];\r\n    }\r\n    const locArr = [];\r\n    const testThing = tempGrid.filter((tempItem) => {\r\n      let moreTemp = tempItem.props.id;\r\n      if (moreTemp === tempI) {\r\n        locArr[0] = parseInt(tempItem.props.children);\r\n        locArr[1] = parseInt(\r\n          tempItem.props.children.slice(locArr[0].length + 1)\r\n        );\r\n      }\r\n      return moreTemp !== tempI;\r\n    });\r\n\r\n    return testThing;\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  function RebuildCell(tempI) {\r\n    let i = tempI;\r\n    let j = 0;\r\n\r\n    // creates the keys for rows/cols\r\n    while (i >= GridDetails.numRows) {\r\n      i -= GridDetails.numRows;\r\n      j++;\r\n    }\r\n    return BuildCell(j, i, \"visitedNode\", tempI);\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  function FindNeighbors() {\r\n    let repairedGrid = [];\r\n    let i = 0;\r\n    do {\r\n      let damagedGrid = [...getGrid];\r\n      let searchSpot;\r\n      let tempInfo = {\r\n        rebuildCell: false,\r\n        iLoc: 0,\r\n      };\r\n\r\n      if (searchArray.length <= 0) {\r\n        console.log(\"searchArray empty\");\r\n        return;\r\n      }\r\n\r\n      searchSpot = searchArray.shift();\r\n\r\n      tempInfo = SearchNeighbors(searchSpot, \"up\", getGrid);\r\n      if (tempInfo.rebuildCell) {\r\n        damagedGrid = DestroyCell(tempInfo.iLoc, damagedGrid);\r\n        damagedGrid.push(RebuildCell(tempInfo.iLoc));\r\n      }\r\n      tempInfo = SearchNeighbors(searchSpot, \"right\", getGrid);\r\n      if (tempInfo.rebuildCell) {\r\n        damagedGrid = DestroyCell(tempInfo.iLoc, damagedGrid);\r\n        damagedGrid.push(RebuildCell(tempInfo.iLoc));\r\n      }\r\n      tempInfo = SearchNeighbors(searchSpot, \"down\", getGrid);\r\n      if (tempInfo.rebuildCell) {\r\n        damagedGrid = DestroyCell(tempInfo.iLoc, damagedGrid);\r\n        damagedGrid.push(RebuildCell(tempInfo.iLoc));\r\n      }\r\n      tempInfo = SearchNeighbors(searchSpot, \"left\", getGrid);\r\n      if (tempInfo.rebuildCell) {\r\n        damagedGrid = DestroyCell(tempInfo.iLoc, damagedGrid);\r\n        damagedGrid.push(RebuildCell(tempInfo.iLoc));\r\n      }\r\n\r\n      repairedGrid = SortGrid(damagedGrid);\r\n      setGrid(repairedGrid);\r\n\r\n      i++;\r\n    } while (i < 7);\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  function SortGrid(currGrid) {\r\n    const tempGrid = [...currGrid];\r\n    tempGrid.sort((a, b) => {\r\n      return a.props.id - b.props.id;\r\n    });\r\n    return tempGrid;\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  function LogArray() {\r\n    console.log(searchArray);\r\n  }\r\n\r\n  ////////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n  function PrintGrid() {\r\n    console.log(\" - - - \");\r\n    console.log(getGrid);\r\n  }\r\n\r\n  return (\r\n    <>\r\n      <div>Render Count: {renderCount.current}</div>\r\n      {getGrid}\r\n      {/* <button onClick={() => RebuildCell(getCount)}>Test</button> */}\r\n      <button onClick={() => PrintGrid()}>Print Grid</button>\r\n      <button onClick={() => FindNeighbors()}>Find Neighbor</button>\r\n      <button onClick={() => LogArray()}>Log Array</button>\r\n    </>\r\n  );\r\n}\r\n\r\nfunction SearchNeighbors(searchSpot, dir, grid) {\r\n  let focusSpot; // the cell to be analyzed\r\n\r\n  // initialize where the search is focusing\r\n  if (dir === \"up\") {\r\n    // 0, -1\r\n    focusSpot = [searchSpot[0], searchSpot[1] - 1];\r\n  } else if (dir === \"right\") {\r\n    // +1, 0\r\n    focusSpot = [searchSpot[0] + 1, searchSpot[1]];\r\n  } else if (dir === \"down\") {\r\n    // 0, +1\r\n    focusSpot = [searchSpot[0], searchSpot[1] + 1];\r\n  } else if (dir === \"left\") {\r\n    // -1, 0\r\n    focusSpot = [searchSpot[0] - 1, searchSpot[1]];\r\n  }\r\n\r\n  // checks to see if the focus is over a border\r\n  if (focusSpot[1] < 0) {\r\n    console.log(\"top border\");\r\n    return { rebuildCell: false };\r\n  } else if (focusSpot[0] >= GridDetails.numCols) {\r\n    console.log(\"right border\");\r\n    return { rebuildCell: false };\r\n  } else if (focusSpot[1] >= GridDetails.numRows) {\r\n    console.log(\"bottom border\");\r\n    return { rebuildCell: false };\r\n  } else if (focusSpot[0] < 0) {\r\n    console.log(\"left border\");\r\n    return { rebuildCell: false };\r\n  }\r\n\r\n  // check to see if focus is start node\r\n  if (focusSpot[0] === StartNode.xLoc && focusSpot[1] === StartNode.yLoc) {\r\n    console.log(\"is start node\");\r\n    return { rebuildCell: false };\r\n\r\n    // check to see if focus is end node\r\n  } else if (focusSpot[0] === EndNode.xLoc && focusSpot[1] === EndNode.yLoc) {\r\n    console.log(\"is end node\");\r\n    searchArray = [];\r\n    return { rebuildCell: false };\r\n  }\r\n\r\n  // setup for visited test\r\n  const tempGrid = [...grid];\r\n  const tempCell = tempGrid.filter((cell) => {\r\n    if (cell.props.children === focusSpot[0] + \", \" + focusSpot[1]) {\r\n      return cell;\r\n    }\r\n  });\r\n\r\n  // checks to see if focus has been visited\r\n  if (tempCell[0].props.className.includes(\" visitedNode\")) {\r\n    return { rebuildCell: false };\r\n  }\r\n\r\n  // if all tests are true, push spot in searchArray and return true for cell rebuild\r\n  searchArray.push(focusSpot);\r\n  return { rebuildCell: true, iLoc: tempCell[0].props.id };\r\n}\r\n\r\nfunction InitializeGrid() {\r\n  let tempVar = 0;\r\n  const gridArray = [];\r\n  for (let i = 0; i < GridDetails.numCols; i++) {\r\n    for (let j = 0; j < GridDetails.numRows; j++) {\r\n      gridArray.push(BuildCell(i, j, \"unvisitedNode\", tempVar));\r\n      tempVar++;\r\n    }\r\n  }\r\n  return gridArray;\r\n}\r\n\r\nfunction BuildCell(i, j, className, id) {\r\n  let tempClass = className;\r\n\r\n  const HandleClick = (e) => {\r\n    console.log(cellDetails.id);\r\n    console.log(e.target);\r\n    let temp = e.target;\r\n    temp.className = temp.className + \" visitedNode\";\r\n  };\r\n\r\n  const gridDetails = GridDetails;\r\n  let cellDetails;\r\n\r\n  if (i === StartNode.xLoc && j === StartNode.yLoc) {\r\n    cellDetails = { ...StartNode };\r\n    tempClass = cellDetails.className;\r\n  } else if (i === EndNode.xLoc && j === EndNode.yLoc) {\r\n    cellDetails = { ...EndNode };\r\n    tempClass = cellDetails.className;\r\n  } else {\r\n    cellDetails = { ...CellDetails };\r\n    cellDetails.xLoc = i;\r\n    cellDetails.yLoc = j;\r\n  }\r\n\r\n  cellDetails.moveX = i * GridDetails.cellSize + GridDetails.margin;\r\n  cellDetails.moveY = j * GridDetails.cellSize + GridDetails.margin;\r\n\r\n  return (\r\n    <div\r\n      id={id}\r\n      key={`${i}, ${j}`}\r\n      onClick={(e) => HandleClick(e)}\r\n      className={`gridCell ${tempClass}`}\r\n      style={{\r\n        //   animation: `clickCell ${delay}s`, // this is the key to getting each individual cell to animate separately\r\n        left: `${cellDetails.moveX}px`,\r\n        top: `${cellDetails.moveY}px`,\r\n        width: gridDetails.cellSize,\r\n        height: gridDetails.cellSize,\r\n      }}\r\n    >{`${cellDetails.xLoc}, ${cellDetails.yLoc}`}</div>\r\n  );\r\n}\r\n","C:\\Users\\sevis\\OneDrive\\Desktop\\reactPortfolio\\src\\GridDetails.js",[],["27","28"],{"ruleId":"29","replacedBy":"30"},{"ruleId":"31","replacedBy":"32"},{"ruleId":"33","severity":1,"message":"34","line":5,"column":10,"nodeType":"35","messageId":"36","endLine":5,"endColumn":15},{"ruleId":"33","severity":1,"message":"37","line":7,"column":12,"nodeType":"35","messageId":"36","endLine":7,"endColumn":15},{"ruleId":"38","severity":1,"message":"39","line":186,"column":43,"nodeType":"40","messageId":"41","endLine":186,"endColumn":45},{"ruleId":"29","replacedBy":"42"},{"ruleId":"31","replacedBy":"43"},"no-native-reassign",["44"],"no-negated-in-lhs",["45"],"no-unused-vars","'count' is assigned a value but never used.","Identifier","unusedVar","'Add' is defined but never used.","array-callback-return","Array.prototype.filter() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd",["44"],["45"],"no-global-assign","no-unsafe-negation"]